generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
  // output = "../node_modules/.prisma/client"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Branch {
  id              Int           @id @default(autoincrement())
  code            String        @unique // short code like "HCM-D1"
  name            String
  address         String        @db.VarChar(1024)
  phone           String?       @db.VarChar(50)
  latitude        Decimal?      @db.Decimal(10, 7) // e.g. 10.7768890
  longitude       Decimal?      @db.Decimal(10, 7) // e.g. 106.7008060
  hours           Json? // {"mon_fri":"09:00-21:00","sat_sun":"10:00-20:00"}
  isActive        Boolean       @default(true)
  managerId       Int?          @unique // Branch manager (User with ADMIN role)
  manager         User?         @relation("BranchManager", fields: [managerId], references: [id])
  // Relations
  stocks          Stock[]
  shippings       Shipping[]
  transactions    Transaction[]
  notices         Notice[]
  cartItemsSource CartItem[]    @relation("CartItemSource") // Items shipping from this branch
  cartItemsPickup CartItem[]    @relation("CartItemPickup") // Items being picked up at this branch
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

model Stock {
  id       Int @id @default(autoincrement())
  branchId Int
  sizeId   Int
  quantity Int

  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)
  size   Size   @relation(fields: [sizeId], references: [id], onDelete: Cascade)

  @@unique([branchId, sizeId]) // one row per size per branch
  @@index([sizeId])
  @@index([branchId])
}

model Cart {
  id         Int        @id @default(autoincrement())
  userId     Int
  state      State      @default(PENDING)
  user       User       @relation(fields: [userId], references: [id])
  items      CartItem[]
  couponCode String?
  address    String? // <-- Add this line
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
}

model CartItem {
  id                Int       @id @default(autoincrement())
  cartId            Int
  ClothesId         Int
  sizeId            Int
  totalprice        Float     @default(0)
  quantity          Int
  fulfillmentMethod String    @default("ship") // 'ship' or 'pickup'
  sourceBranchId    Int? // Which branch this item ships from or is picked up at
  sourceBranch      Branch?   @relation("CartItemSource", fields: [sourceBranchId], references: [id])
  pickupBranchId    Int? // For pickup: which branch to pick up at
  pickupBranch      Branch?   @relation("CartItemPickup", fields: [pickupBranchId], references: [id])
  needsTransfer     Boolean   @default(false) // If item needs transfer from warehouse to pickup location
  estimatedDate     DateTime? // ETA for transfer or delivery
  allocationNote    String?   @db.VarChar(512) // Notes about allocation (e.g., "Ships from warehouse")
  Clothes           Clothes   @relation(fields: [ClothesId], references: [id])
  Size              Size      @relation(fields: [sizeId], references: [id])
  cart              Cart      @relation(fields: [cartId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Comment {
  id                  Int               @id @default(autoincrement())
  userId              Int
  transactionDetailId Int
  content             String            @db.VarChar(1024)
  rating              Int // 1-5 star rating
  isVerifiedPurchase  Boolean           @default(true) // Always true since linked to transaction
  user                User              @relation(fields: [userId], references: [id])
  transactionDetail   TransactionDetail @relation(fields: [transactionDetailId], references: [id])
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  // Ensure one comment per user per transaction detail
  @@unique([userId, transactionDetailId])
}

model Coupon {
  id           Int           @id @default(autoincrement())
  couponCode   String        @unique
  description  String        @db.VarChar(1024)
  discount     Float
  expiryDate   DateTime
  isActive     Boolean       @default(true)
  stock        Int           @default(0) // Number of times this coupon can be used
  transactions Transaction[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
}

model Clothes {
  id          Int        @id @default(autoincrement())
  name        String     @unique
  description String     @db.VarChar(1024)
  price       Float
  material    String?    @db.VarChar(255)
  information String?    @db.VarChar(1024)
  mainImgId   Int?       @unique
  cartItems   CartItem[]
  categoryId  Int
  category    Category   @relation(fields: [categoryId], references: [id])

  mainImg            Image?              @relation(fields: [mainImgId], references: [id], name: "MainImage", onDelete: Cascade, onUpdate: Cascade)
  extraImgs          Image[]             @relation(name: "ExtraImages")
  transactionDetails TransactionDetail[]
  sizes              Size[]
  features           Feature[]
  sharedInMessages   Message[] // Products shared in messages
  c2cListings        C2CListing[] // C2C marketplace listings
  inventory          Inventory[] // User inventory items

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Size {
  id                 Int                 @id @default(autoincrement())
  label              String // ví dụ "M", "L", "XL"
  quantity           Int
  clothesId          Int
  clothes            Clothes             @relation(fields: [clothesId], references: [id], onDelete: Cascade)
  transactionDetails TransactionDetail[]
  cartItems          CartItem[]
  stocks             Stock[]
  c2cListings        C2CListing[] // C2C marketplace listings
  inventory          Inventory[] // User inventory items
}

model Feature {
  id        Int     @id @default(autoincrement())
  value     String // ví dụ "Cotton 100%"
  clothesId Int
  clothes   Clothes @relation(fields: [clothesId], references: [id], onDelete: Cascade)
}

model Image {
  id            Int       @id @default(autoincrement()) // Primary key
  name          String
  url           String    @unique @db.VarChar(500)
  ClothesMain   Clothes?  @relation(name: "MainImage")
  ClothesExtras Clothes[] @relation(name: "ExtraImages")
  Notice        Notice[]
  UserAvatar    User?     @relation(name: "UserAvatar")
}

model Category {
  id      Int       @id @default(autoincrement())
  name    String    @unique
  Clothes Clothes[]
}

model User {
  id                     Int               @id @default(autoincrement())
  name                   String
  email                  String            @unique
  password               String            @db.VarChar(1024)
  phone                  String
  address                String            @db.VarChar(1024)
  role                   Role              @default(USER)
  points                 Int               @default(0)
  avatarId               Int?              @unique
  avatar                 Image?            @relation(fields: [avatarId], references: [id], name: "UserAvatar")
  managedBranch          Branch?           @relation("BranchManager")
  carts                  Cart[]
  comments               Comment[]
  shippings              Shipping[]
  transactions           Transaction[]
  notices                Notice[]
  passwordHistory        PasswordHistory[]
  pointHistory           PointHistory[]
  refunds                Refund[]
  // Friendship relations
  friendRequestsSent     Friendship[]      @relation("FriendshipRequester")
  friendRequestsReceived Friendship[]      @relation("FriendshipAddressee")
  // Conversation relations
  conversationsAsUser1   Conversation[]    @relation("ConversationUser1")
  conversationsAsUser2   Conversation[]    @relation("ConversationUser2")
  // Message relations
  messagesSent           Message[]         @relation("MessageSender")
  // Post relations
  posts                  Post[]
  postLikes              PostLike[]
  postComments           PostComment[]
  // C2C Relations
  c2cListings            C2CListing[]       @relation("SellerListings")
  c2cBuyTrades           C2CTrade[]         @relation("BuyerTrades")
  c2cSellTrades          C2CTrade[]         @relation("SellerTrades")
  c2cTradeMessages       C2CTradeMessage[]
  c2cReviewsGiven        C2CReview[]        @relation("ReviewsGiven")
  c2cReviewsReceived     C2CReview[]        @relation("ReviewsReceived")
  c2cReputation          C2CReputation[]
  // Inventory
  inventory              Inventory[]
  updatedAt              DateTime          @updatedAt
  createdAt              DateTime          @default(now())
  otpCode                String?
  otpExpiry              DateTime?
  resetToken             String?
  resetTokenExpiry       DateTime?
  isVerified             Boolean           @default(false)
  // E2E Encryption keys with envelope encryption
  publicKey              String?           @db.Text
  publicKeyDevices       Json? // Array of devices: [{ name: "Chrome on Windows", addedAt: "2025-12-11T...", userAgent: "..." }]
  publicKeyUpdatedAt     DateTime? // When the public key was last updated
  encryptedPrivateKey    String?           @db.Text // Private key encrypted with master key (one-time encryption)
  privateKeyIV           String?           @db.VarChar(255) // IV for private key encryption
  masterKeyWrappedByPin  String?           @db.Text // Master key wrapped (encrypted) with PIN
  pinWrapIV              String?           @db.VarChar(255) // IV for PIN wrap
  recoveryCodeWraps      RecoveryCodeWrap[] // Recovery codes that can unwrap master key
}

model RecoveryCodeWrap {
  id                Int      @id @default(autoincrement())
  userId            Int
  codeHash          String   @db.VarChar(64) // SHA-256 hash of recovery code (NEVER store plain!)
  wrappedMasterKey  String   @db.Text // Master key wrapped with this recovery code
  wrapIV            String   @db.VarChar(255) // IV for this wrap
  isUsed            Boolean  @default(false)
  usedAt            DateTime?
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt         DateTime @default(now())

  @@unique([userId, codeHash]) // One wrap per code per user
  @@index([userId])
  @@index([codeHash])
}

// User inventory for tracking owned clothes
model Inventory {
  id              Int              @id @default(autoincrement())
  userId          Int
  clothesId       Int
  sizeId          Int
  quantity        Int              @default(1)
  source          InventorySource  @default(STORE) // Where the item was acquired
  sourceReference String?          @db.VarChar(255) // Transaction ID or Trade ID
  acquiredAt      DateTime         @default(now())
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  clothes         Clothes          @relation(fields: [clothesId], references: [id])
  size            Size             @relation(fields: [sizeId], references: [id])
  
  @@unique([userId, clothesId, sizeId, sourceReference]) // Prevent duplicate entries
  @@index([userId])
  @@index([clothesId])
  @@index([sizeId])
  @@index([source])
}

enum InventorySource {
  STORE        // Bought from store
  C2C_PURCHASE // Bought from C2C market
}

model Shipping {
  id                  Int               @id @default(autoincrement())
  address             String            @db.VarChar(1024)
  userId              Int
  transactionDetailId Int               @unique
  State               State             @default(PENDING)
  branchId            Int? // NEW: ship-from or pickup branch
  branch              Branch?           @relation(fields: [branchId], references: [id])
  user                User              @relation(fields: [userId], references: [id])
  type                Type              @default(SHIP)
  transactionDetail   TransactionDetail @relation(fields: [transactionDetailId], references: [id])
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
}

model Transaction {
  id                 Int                 @id @default(autoincrement())
  amount             Float
  method             String
  userId             Int
  couponCode         String?
  branchId           Int?                 // NEW: fulfilled by branch
  branch             Branch?             @relation(fields: [branchId], references: [id])
  user               User                @relation(fields: [userId], references: [id])
  coupon             Coupon?             @relation(fields: [couponCode], references: [couponCode])
  transactionDetails TransactionDetail[]
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
}

enum Role {
  ADMIN
  HOST
  USER
}

enum State {
  ORDERED
  PENDING
  SHIPPING
  COMPLETE
}

enum Type {
  SHIP
  PICKUP
}

model TransactionDetail {
  id               Int         @id @default(autoincrement())
  transactionId    Int
  clothesId        Int
  sizeId           Int
  quantity         Int
  price            Float
  refundedQuantity Int         @default(0)
  transaction      Transaction @relation(fields: [transactionId], references: [id])
  clothes          Clothes     @relation(fields: [clothesId], references: [id])
  size             Size        @relation(fields: [sizeId], references: [id])
  shipping         Shipping?
  refunds          Refund[]
  comments         Comment[]
  createdAt        DateTime    @default(now())
}

model Notice {
  id        Int      @id @default(autoincrement())
  title     String
  subtitle  String?
  content   String
  imageId   Int?
  image     Image?   @relation(fields: [imageId], references: [id])
  pages     Json
  userId    Int? // <-- Add this line
  user      User?    @relation(fields: [userId], references: [id])
  branchId  Int? // NEW: branch-specific banner/news
  branch    Branch?  @relation(fields: [branchId], references: [id])
  state     Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Log {
  id        Int      @id @default(autoincrement())
  userId    Int
  userName  String
  action    String
  createdAt DateTime @default(now())
}

model PasswordHistory {
  id               Int      @id @default(autoincrement())
  userId           Int
  previousPassword String   @db.VarChar(1024)
  rollbackToken    String   @unique
  tokenExpiry      DateTime
  isUsed           Boolean  @default(false)
  user             User     @relation(fields: [userId], references: [id])
  createdAt        DateTime @default(now())
}

model PointHistory {
  id            Int       @id @default(autoincrement())
  userId        Int
  points        Int // Positive for earning, negative for spending/refund
  type          PointType
  description   String
  transactionId Int? // Optional reference to transaction
  refundId      Int? // Optional reference to refund
  user          User      @relation(fields: [userId], references: [id])
  createdAt     DateTime  @default(now())
}

model Refund {
  id                  Int               @id @default(autoincrement())
  userId              Int
  transactionDetailId Int
  quantity            Int // How many items being refunded
  refundAmount        Float // Amount to refund in currency
  pointsReturned      Int // Points returned for this refund
  reason              String?           @db.VarChar(1024)
  status              RefundStatus      @default(PENDING)
  adminNote           String?           @db.VarChar(1024)
  user                User              @relation(fields: [userId], references: [id])
  transactionDetail   TransactionDetail @relation(fields: [transactionDetailId], references: [id])
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
}

// Friendship system
model Friendship {
  id          Int              @id @default(autoincrement())
  requesterId Int // User who sent the friend request
  addresseeId Int // User who received the friend request
  status      FriendshipStatus @default(PENDING)
  requester   User             @relation("FriendshipRequester", fields: [requesterId], references: [id], onDelete: Cascade)
  addressee   User             @relation("FriendshipAddressee", fields: [addresseeId], references: [id], onDelete: Cascade)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@unique([requesterId, addresseeId]) // Prevent duplicate friend requests
  @@index([requesterId])
  @@index([addresseeId])
  @@index([status])
}

// Chat conversations between users
model Conversation {
  id        Int       @id @default(autoincrement())
  user1Id   Int // First user in conversation
  user2Id   Int // Second user in conversation
  user1     User      @relation("ConversationUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2     User      @relation("ConversationUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  messages  Message[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@unique([user1Id, user2Id]) // One conversation per user pair
  @@index([user1Id])
  @@index([user2Id])
}

// Chat messages
model Message {
  id               Int          @id @default(autoincrement())
  conversationId   Int
  senderId         Int
  content          String?      @db.Text // Plain text or binary-encoded (when not encrypted)
  encryptedContent String?      @db.Text // AES encrypted content (when isEncrypted = true)
  iv               String?      @db.VarChar(512) // Initialization Vector for AES
  encryptedAESKey  String?      @db.Text // AES key encrypted with recipient's public RSA key
  aesKey           String?      @db.VarChar(512) // Plain AES key (stored for sender to decrypt own messages)
  messageType      MessageType  @default(TEXT) // TEXT, PRODUCT, IMAGE
  productId        Int? // If sharing a product
  imageUrl         String?      @db.VarChar(512) // If sending an image
  isRead           Boolean      @default(false)
  isEncrypted      Boolean      @default(false) // True if content is E2E encrypted
  conversation     Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender           User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  product          Clothes?     @relation(fields: [productId], references: [id], onDelete: SetNull)
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
}

enum FriendshipStatus {
  PENDING // Friend request sent, awaiting response
  ACCEPTED // Friends
  BLOCKED // User blocked
}

enum MessageType {
  TEXT // Regular text message
  PRODUCT // Shared product
  IMAGE // Image message
}

enum PointType {
  EARNED_PAYMENT // Points earned from payment
  RETURNED_REFUND // Points returned from refund
  SPENT_PURCHASE // Points spent on purchase (for future use)
  ADMIN_ADJUSTMENT // Manual adjustment by admin
}

enum RefundStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

// Instagram-like posts
model Post {
  id        Int           @id @default(autoincrement())
  userId    Int
  caption   String?       @db.Text
  location  String?       @db.VarChar(255)
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  images    PostImage[]
  likes     PostLike[]
  comments  PostComment[]
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  @@index([userId])
  @@index([createdAt])
}

model PostImage {
  id        Int      @id @default(autoincrement())
  postId    Int
  imageUrl  String   @db.VarChar(512)
  order     Int      @default(0) // Display order
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([postId])
}

model PostLike {
  id        Int      @id @default(autoincrement())
  postId    Int
  userId    Int
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([postId, userId]) // One like per user per post
  @@index([postId])
  @@index([userId])
}

model PostComment {
  id        Int      @id @default(autoincrement())
  postId    Int
  userId    Int
  content   String   @db.Text
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
  @@index([userId])
}

// ============================================
// C2C MARKETPLACE MODELS
// ============================================

// Customer listing to sell store clothing
model C2CListing {
  id              String              @id @default(uuid())
  sellerId        Int
  clothesId       Int                 // REQUIRED: Must be from store catalog
  sizeId          Int?                // OPTIONAL: If specified, must belong to clothesId
  condition       ClothesCondition
  description     String              @db.Text
  price           Decimal             @db.Decimal(10, 2)
  status          ListingStatus       @default(ACTIVE)
  viewCount       Int                 @default(0)
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  // Relations
  seller          User                @relation("SellerListings", fields: [sellerId], references: [id], onDelete: Cascade)
  clothes         Clothes             @relation(fields: [clothesId], references: [id])
  size            Size?               @relation(fields: [sizeId], references: [id], onDelete: Restrict)
  trades          C2CTrade[]
  images          ListingImage[]
  
  @@index([sellerId])
  @@index([clothesId])
  @@index([sizeId])
  @@index([status])
  @@index([createdAt])
}

// Images for C2C listings (seller's actual photos)
model ListingImage {
  id        String     @id @default(uuid())
  listingId String
  imageUrl  String     @db.VarChar(512)
  order     Int        @default(0)
  createdAt DateTime   @default(now())
  
  listing   C2CListing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  
  @@index([listingId])
}

// Trade between buyer and seller
model C2CTrade {
  id                    String            @id @default(uuid())
  listingId             String
  buyerId               Int
  sellerId              Int
  agreedPrice           Decimal           @db.Decimal(10, 2)
  
  // Status tracking
  status                C2CTradeStatus    @default(INITIATED)
  
  // Payment
  paymentMethod         PaymentMethod?
  paymentAmount         Decimal?          @db.Decimal(10, 2)
  paidAt                DateTime?
  paymentConfirmedAt    DateTime?
  paymentProof          String?           @db.Text
  
  // Delivery
  deliveryMethod        DeliveryMethod?
  deliveryAddress       String?           @db.Text
  shippingFee           Decimal?          @db.Decimal(10, 2)
  shippedAt             DateTime?
  deliveredAt           DateTime?
  deliveryProof         String?           @db.Text
  
  // Completion
  autoCompleteAt        DateTime?
  completedAt           DateTime?
  
  // Dispute
  disputedAt            DateTime?
  disputeReason         String?           @db.Text
  disputeResolvedAt     DateTime?
  resolutionNote        String?           @db.Text
  
  // Cancellation
  cancelledAt           DateTime?
  cancelReason          String?           @db.Text
  
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  // Relations
  listing               C2CListing        @relation(fields: [listingId], references: [id])
  buyer                 User              @relation("BuyerTrades", fields: [buyerId], references: [id])
  seller                User              @relation("SellerTrades", fields: [sellerId], references: [id])
  messages              C2CTradeMessage[]
  reviews               C2CReview[]
  
  @@index([listingId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
  @@index([autoCompleteAt])
  @@index([createdAt])
}

// Trade messages between buyer and seller
model C2CTradeMessage {
  id        String           @id @default(uuid())
  tradeId   String
  senderId  Int
  type      TradeMessageType @default(TEXT)
  content   String           @db.Text
  metadata  Json?
  createdAt DateTime         @default(now())
  
  trade     C2CTrade         @relation(fields: [tradeId], references: [id], onDelete: Cascade)
  sender    User             @relation(fields: [senderId], references: [id])
  
  @@index([tradeId])
  @@index([senderId])
  @@index([createdAt])
}

// Reviews after trade completion
model C2CReview {
  id         String     @id @default(uuid())
  tradeId    String
  reviewerId Int
  revieweeId Int
  role       ReviewRole
  rating     Int
  comment    String?    @db.Text
  createdAt  DateTime   @default(now())
  
  trade      C2CTrade   @relation(fields: [tradeId], references: [id])
  reviewer   User       @relation("ReviewsGiven", fields: [reviewerId], references: [id])
  reviewee   User       @relation("ReviewsReceived", fields: [revieweeId], references: [id])
  
  @@unique([tradeId, reviewerId])
  @@index([reviewerId])
  @@index([revieweeId])
  @@index([tradeId])
}

// Reputation tracking (separate for buyer/seller roles)
model C2CReputation {
  id               String     @id @default(uuid())
  userId           Int
  role             ReviewRole
  
  // Ratings
  averageRating    Decimal    @default(0.00) @db.Decimal(3, 2)
  totalRatings     Int        @default(0)
  
  // Trade stats
  totalTrades      Int        @default(0)
  completedTrades  Int        @default(0)
  disputedTrades   Int        @default(0)
  cancelledTrades  Int        @default(0)
  
  // Calculated metrics
  completionRate   Decimal    @default(0.00) @db.Decimal(5, 2)
  disputeRate      Decimal    @default(0.00) @db.Decimal(5, 2)
  responseTimeAvg  Int?
  
  lastCalculatedAt DateTime   @default(now())
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  
  user             User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, role])
  @@index([userId])
  @@index([role])
  @@index([averageRating])
}

enum ClothesCondition {
  NEW
  LIKE_NEW
  GOOD
  FAIR
}

enum ListingStatus {
  ACTIVE
  RESERVED
  SOLD
  CANCELLED
  INACTIVE
}

enum C2CTradeStatus {
  INITIATED
  PAYMENT_PENDING
  PAYMENT_CONFIRMED
  SHIPPING
  DELIVERED
  COMPLETED
  CANCELLED
  DISPUTED
  DISPUTE_RESOLVED
}

enum PaymentMethod {
  VNPAY
  MOMO
  WALLET_TOKENS
  BANK_TRANSFER
  CASH_ON_DELIVERY
  OTHER
}

enum DeliveryMethod {
  SHIP
  MEETUP
  OTHER
}

enum TradeMessageType {
  TEXT
  SYSTEM
  PAYMENT_PROOF
  DELIVERY_PROOF
}

enum ReviewRole {
  BUYER
  SELLER
}
